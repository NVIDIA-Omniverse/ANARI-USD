// Copyright 2021 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_debug_objects.py
// Don't make changes to this directly

#include "anari/ext/debug/DebugObject.h"
using namespace anari::debug_device;
namespace anari {
namespace usd {
class UsdDeviceDebugFactory : public anari::debug_device::ObjectFactory {
public:
anari::debug_device::DebugObjectBase* new_geometry(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_material(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_renderer(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_sampler(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_spatial_field(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_volume(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_device(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_array1d(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_array2d(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_array3d(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_frame(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_group(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_instance(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_world(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_surface(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   void print_summary(anari::debug_device::DebugDevice *td) override;
   void use_feature(int feature);
};
namespace {
class device : public DebugObject<ANARI_DEVICE> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610008u,0x0u,0x0u,0x0u,0x0u,0x7574000cu,0x0u,0x74730077u,0x6e6d0009u,0x6665000au,0x100000bu,0x80000000u,0x6261000du,0x7574000eu,0x7675000fu,0x74730010u,0x44430011u,0x62610012u,0x6d6c0013u,0x6d6c0014u,0x63620015u,0x62610016u,0x64630017u,0x6c6b0018u,0x56000019u,0x80000001u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7473006fu,0x66650070u,0x73720071u,0x45440072u,0x62610073u,0x75740074u,0x62610075u,0x1000076u,0x80000002u,0x65640078u,0x3b3a0079u,0x3b3a007au,0x7865007bu,0x6f6e008eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6665009au,0x767500a4u,0x0u,0x0u,0x0u,0x666300d6u,0x6a69010eu,0x0u,0x0u,0x73720112u,0x6261008fu,0x63620090u,0x6d6c0091u,0x66650092u,0x54530093u,0x62610094u,0x77760095u,0x6a690096u,0x6f6e0097u,0x68670098u,0x1000099u,0x8000000du,0x7877009bu,0x5453009cu,0x6665009du,0x7473009eu,0x7473009fu,0x6a6900a0u,0x706f00a1u,0x6f6e00a2u,0x10000a3u,0x80000006u,0x757400a5u,0x717000a6u,0x767500a7u,0x757400a8u,0x2f2e00a9u,0x716d00aau,0x656100aeu,0x0u,0x0u,0x737200c1u,0x757400b2u,0x0u,0x0u,0x6d6c00b9u,0x666500b3u,0x737200b4u,0x6a6900b5u,0x626100b6u,0x6d6c00b7u,0x10000b8u,0x80000009u,0x545300bau,0x696800bbu,0x626100bcu,0x656400bdu,0x666500beu,0x737200bfu,0x10000c0u,0x8000000bu,0x6a6900c2u,0x666500c3u,0x777600c4u,0x6a6900c5u,0x666500c6u,0x787700c7u,0x545300c8u,0x767500c9u,0x737200cau,0x676600cbu,0x626100ccu,0x646300cdu,0x666500ceu,0x545300cfu,0x696800d0u,0x626100d1u,0x656400d2u,0x666500d3u,0x737200d4u,0x10000d5u,0x8000000au,0x666500d9u,0x0u,0x737200e2u,0x6f6e00dau,0x666500dbu,0x545300dcu,0x757400ddu,0x626100deu,0x686700dfu,0x666500e0u,0x10000e1u,0x8000000cu,0x6a6900e3u,0x626100e4u,0x6d6c00e5u,0x6a6900e6u,0x7b7a00e7u,0x666500e8u,0x2f2e00e9u,0x706800eau,0x706f00f2u,0x0u,0x0u,0x0u,0x706f00fau,0x0u,0x0u,0x76750102u,0x747300f3u,0x757400f4u,0x4f4e00f5u,0x626100f6u,0x6e6d00f7u,0x666500f8u,0x10000f9u,0x80000003u,0x646300fbu,0x626100fcu,0x757400fdu,0x6a6900feu,0x706f00ffu,0x6f6e0100u,0x1000101u,0x80000004u,0x75740103u,0x71700104u,0x76750105u,0x75740106u,0x43420107u,0x6a690108u,0x6f6e0109u,0x6261010au,0x7372010bu,0x7a79010cu,0x100010du,0x80000005u,0x6e6d010fu,0x66650110u,0x1000111u,0x80000007u,0x6a690113u,0x75740114u,0x66650115u,0x42410116u,0x75740117u,0x44430118u,0x706f0119u,0x6e6d011au,0x6e6d011bu,0x6a69011cu,0x7574011du,0x100011eu,0x80000008u};
      uint32_t cur = 0x766e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   device(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //statusCallback
            ANARIDataType statusCallback_types[] = {ANARI_STATUS_CALLBACK, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, statusCallback_types);
            return;
         }
         case 2: { //statusCallbackUserData
            ANARIDataType statusCallbackUserData_types[] = {ANARI_VOID_POINTER, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, statusCallbackUserData_types);
            return;
         }
         case 3: { //usd::serialize.hostName
            ANARIDataType usd__serialize_hostName_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, usd__serialize_hostName_types);
            return;
         }
         case 4: { //usd::serialize.location
            ANARIDataType usd__serialize_location_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, usd__serialize_location_types);
            return;
         }
         case 5: { //usd::serialize.outputBinary
            ANARIDataType usd__serialize_outputBinary_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, usd__serialize_outputBinary_types);
            return;
         }
         case 6: { //usd::newSession
            ANARIDataType usd__newSession_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, usd__newSession_types);
            return;
         }
         case 7: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, usd__time_types);
            return;
         }
         case 8: { //usd::writeAtCommit
            ANARIDataType usd__writeAtCommit_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, usd__writeAtCommit_types);
            return;
         }
         case 9: { //usd::output.material
            ANARIDataType usd__output_material_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, usd__output_material_types);
            return;
         }
         case 10: { //usd::output.prieviewSurfaceShader
            ANARIDataType usd__output_prieviewSurfaceShader_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, usd__output_prieviewSurfaceShader_types);
            return;
         }
         case 11: { //usd::output.mdlShader
            ANARIDataType usd__output_mdlShader_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, usd__output_mdlShader_types);
            return;
         }
         case 12: { //usd::sceneStage
            ANARIDataType usd__sceneStage_types[] = {ANARI_VOID_POINTER, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, usd__sceneStage_types);
            return;
         }
         case 13: { //usd::enableSaving
            ANARIDataType usd__enableSaving_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, usd__enableSaving_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_DEVICE, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class array1d : public DebugObject<ANARI_ARRAY1D> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610001u,0x6e6d0002u,0x66650003u,0x1000004u,0x80000000u};
      uint32_t cur = 0x6f6e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   array1d(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_ARRAY1D, "", paramname, paramtype, name_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_ARRAY1D, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class array2d : public DebugObject<ANARI_ARRAY2D> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610001u,0x6e6d0002u,0x66650003u,0x1000004u,0x80000000u};
      uint32_t cur = 0x6f6e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   array2d(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_ARRAY2D, "", paramname, paramtype, name_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_ARRAY2D, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class array3d : public DebugObject<ANARI_ARRAY3D> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610001u,0x6e6d0002u,0x66650003u,0x1000004u,0x80000000u};
      uint32_t cur = 0x6f6e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   array3d(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_ARRAY3D, "", paramname, paramtype, name_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_ARRAY3D, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class frame : public DebugObject<ANARI_FRAME> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x69610015u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610034u,0x0u,0x0u,0x0u,0x66650038u,0x6a690040u,0x0u,0x0u,0x0u,0x706f0044u,0x6e6d001du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610022u,0x6665001eu,0x7372001fu,0x62610020u,0x1000021u,0x80000003u,0x6f6e0023u,0x6f6e0024u,0x66650025u,0x6d6c0026u,0x2f2e0027u,0x65630028u,0x706f002au,0x6665002fu,0x6d6c002bu,0x706f002cu,0x7372002du,0x100002eu,0x80000005u,0x71700030u,0x75740031u,0x69680032u,0x1000033u,0x80000006u,0x6e6d0035u,0x66650036u,0x1000037u,0x80000000u,0x6f6e0039u,0x6564003au,0x6665003bu,0x7372003cu,0x6665003du,0x7372003eu,0x100003fu,0x80000002u,0x7b7a0041u,0x66650042u,0x1000043u,0x80000004u,0x73720045u,0x6d6c0046u,0x65640047u,0x1000048u,0x80000001u};
      uint32_t cur = 0x78630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   frame(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //world
            ANARIDataType world_types[] = {ANARI_WORLD, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, world_types);
            return;
         }
         case 2: { //renderer
            ANARIDataType renderer_types[] = {ANARI_RENDERER, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, renderer_types);
            return;
         }
         case 3: { //camera
            ANARIDataType camera_types[] = {ANARI_CAMERA, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, camera_types);
            return;
         }
         case 4: { //size
            ANARIDataType size_types[] = {ANARI_UINT32_VEC2, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, size_types);
            return;
         }
         case 5: { //channel.color
            ANARIDataType channel_color_types[] = {ANARI_DATA_TYPE, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, channel_color_types);
            return;
         }
         case 6: { //channel.depth
            ANARIDataType channel_depth_types[] = {ANARI_DATA_TYPE, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, channel_depth_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_FRAME, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class group : public DebugObject<ANARI_GROUP> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6a69000bu,0x0u,0x62610010u,0x0u,0x0u,0x0u,0x0u,0x76750014u,0x0u,0x7473001bu,0x706f002bu,0x6867000cu,0x6968000du,0x7574000eu,0x100000fu,0x80000003u,0x6e6d0011u,0x66650012u,0x1000013u,0x80000000u,0x73720015u,0x67660016u,0x62610017u,0x64630018u,0x66650019u,0x100001au,0x80000001u,0x6564001cu,0x3b3a001du,0x3b3a001eu,0x7574001fu,0x6a690020u,0x6e6d0021u,0x66650022u,0x57560023u,0x62610024u,0x73720025u,0x7a790026u,0x6a690027u,0x6f6e0028u,0x68670029u,0x100002au,0x80000004u,0x6d6c002cu,0x7675002du,0x6e6d002eu,0x6665002fu,0x1000030u,0x80000002u};
      uint32_t cur = 0x776c0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   group(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //surface
            ANARIDataType surface_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, surface_types);
            return;
         }
         case 2: { //volume
            ANARIDataType volume_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, volume_types);
            return;
         }
         case 3: { //light
            ANARIDataType light_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, light_types);
            return;
         }
         case 4: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GROUP, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class instance : public DebugObject<ANARI_INSTANCE> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x7372000fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610014u,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720018u,0x74730021u,0x706f0010u,0x76750011u,0x71700012u,0x1000013u,0x80000002u,0x6e6d0015u,0x66650016u,0x1000017u,0x80000000u,0x62610019u,0x6f6e001au,0x7473001bu,0x6766001cu,0x706f001du,0x7372001eu,0x6e6d001fu,0x1000020u,0x80000001u,0x65640022u,0x3b3a0023u,0x3b3a0024u,0x75740025u,0x6a690026u,0x6e6d0027u,0x66650028u,0x57560029u,0x6261002au,0x7372002bu,0x7a79002cu,0x6a69002du,0x6f6e002eu,0x6867002fu,0x1000030u,0x80000003u};
      uint32_t cur = 0x76670000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   instance(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //transform
            ANARIDataType transform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, transform_types);
            return;
         }
         case 2: { //group
            ANARIDataType group_types[] = {ANARI_GROUP, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, group_types);
            return;
         }
         case 3: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_INSTANCE, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class world : public DebugObject<ANARI_WORLD> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6f6e000eu,0x0u,0x0u,0x6a690016u,0x0u,0x6261001bu,0x0u,0x0u,0x0u,0x0u,0x7675001fu,0x0u,0x74730026u,0x706f0036u,0x7473000fu,0x75740010u,0x62610011u,0x6f6e0012u,0x64630013u,0x66650014u,0x1000015u,0x80000001u,0x68670017u,0x69680018u,0x75740019u,0x100001au,0x80000004u,0x6e6d001cu,0x6665001du,0x100001eu,0x80000000u,0x73720020u,0x67660021u,0x62610022u,0x64630023u,0x66650024u,0x1000025u,0x80000002u,0x65640027u,0x3b3a0028u,0x3b3a0029u,0x7574002au,0x6a69002bu,0x6e6d002cu,0x6665002du,0x5756002eu,0x6261002fu,0x73720030u,0x7a790031u,0x6a690032u,0x6f6e0033u,0x68670034u,0x1000035u,0x80000005u,0x6d6c0037u,0x76750038u,0x6e6d0039u,0x6665003au,0x100003bu,0x80000003u};
      uint32_t cur = 0x77690000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   world(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //instance
            ANARIDataType instance_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, instance_types);
            return;
         }
         case 2: { //surface
            ANARIDataType surface_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, surface_types);
            return;
         }
         case 3: { //volume
            ANARIDataType volume_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, volume_types);
            return;
         }
         case 4: { //light
            ANARIDataType light_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, light_types);
            return;
         }
         case 5: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_WORLD, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class renderer_default : public DebugObject<ANARI_RENDERER> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610001u,0x6e6d0002u,0x66650003u,0x1000004u,0x80000000u};
      uint32_t cur = 0x6f6e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   renderer_default(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_RENDERER, "default", paramname, paramtype, name_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_RENDERER, "default", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "default";
   }
};
class surface : public DebugObject<ANARI_SURFACE> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6665000fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610017u,0x6261001fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x74730023u,0x706f0010u,0x6e6d0011u,0x66650012u,0x75740013u,0x73720014u,0x7a790015u,0x1000016u,0x80000001u,0x75740018u,0x66650019u,0x7372001au,0x6a69001bu,0x6261001cu,0x6d6c001du,0x100001eu,0x80000002u,0x6e6d0020u,0x66650021u,0x1000022u,0x80000000u,0x65640024u,0x3b3a0025u,0x3b3a0026u,0x75740027u,0x6a690028u,0x6e6d0029u,0x6665002au,0x5756002bu,0x6261002cu,0x7372002du,0x7a79002eu,0x6a69002fu,0x6f6e0030u,0x68670031u,0x1000032u,0x80000003u};
      uint32_t cur = 0x76670000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   surface(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SURFACE, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //geometry
            ANARIDataType geometry_types[] = {ANARI_GEOMETRY, ANARI_UNKNOWN};
            check_type(ANARI_SURFACE, "", paramname, paramtype, geometry_types);
            return;
         }
         case 2: { //material
            ANARIDataType material_types[] = {ANARI_MATERIAL, ANARI_UNKNOWN};
            check_type(ANARI_SURFACE, "", paramname, paramtype, material_types);
            return;
         }
         case 3: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_SURFACE, "", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SURFACE, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class geometry_cone : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610014u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610018u,0x0u,0x7372001cu,0x0u,0x0u,0x0u,0x0u,0x74730053u,0x666500b9u,0x71700015u,0x74730016u,0x1000017u,0x80000010u,0x6e6d0019u,0x6665001au,0x100001bu,0x80000000u,0x6a69001du,0x6e6d001eu,0x6a69001fu,0x75740020u,0x6a690021u,0x77760022u,0x66650023u,0x2f2e0024u,0x6a610025u,0x7574002eu,0x0u,0x706f003eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640043u,0x7574002fu,0x73720030u,0x6a690031u,0x63620032u,0x76750033u,0x75740034u,0x66650035u,0x34300036u,0x100003au,0x100003bu,0x100003cu,0x100003du,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c003fu,0x706f0040u,0x73720041u,0x1000042u,0x80000001u,0x100004eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6564004fu,0x80000006u,0x66650050u,0x79780051u,0x1000052u,0x8000000fu,0x65640054u,0x3b3a0055u,0x3b3a0056u,0x75740057u,0x6a690058u,0x6e6d0059u,0x6665005au,0x5700005bu,0x80000011u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100b2u,0x737200b3u,0x7a7900b4u,0x6a6900b5u,0x6f6e00b6u,0x686700b7u,0x10000b8u,0x80000012u,0x737200bau,0x757400bbu,0x666500bcu,0x797800bdu,0x2f2e00beu,0x736100bfu,0x757400d1u,0x0u,0x706100e1u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f00f6u,0x0u,0x626100feu,0x757400d2u,0x737200d3u,0x6a6900d4u,0x636200d5u,0x767500d6u,0x757400d7u,0x666500d8u,0x343000d9u,0x10000ddu,0x10000deu,0x10000dfu,0x10000e0u,0x8000000bu,0x8000000cu,0x8000000du,0x8000000eu,0x717000f0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c00f2u,0x10000f1u,0x80000009u,0x706f00f3u,0x737200f4u,0x10000f5u,0x8000000au,0x747300f7u,0x6a6900f8u,0x757400f9u,0x6a6900fau,0x706f00fbu,0x6f6e00fcu,0x10000fdu,0x80000007u,0x656400ffu,0x6a690100u,0x76750101u,0x74730102u,0x1000103u,0x80000008u};
      uint32_t cur = 0x77630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_cone(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.radius
            ANARIDataType vertex_radius_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_radius_types);
            return;
         }
         case 9: { //vertex.cap
            ANARIDataType vertex_cap_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_cap_types);
            return;
         }
         case 10: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_color_types);
            return;
         }
         case 11: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 12: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 13: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 14: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 15: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_index_types);
            return;
         }
         case 16: { //caps
            ANARIDataType caps_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, caps_types);
            return;
         }
         case 17: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, usd__time_types);
            return;
         }
         case 18: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "cone", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "cone";
   }
};
class geometry_curve : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610009u,0x0u,0x7372000du,0x0u,0x62610044u,0x0u,0x0u,0x7473004au,0x666500b0u,0x6e6d000au,0x6665000bu,0x100000cu,0x80000000u,0x6a69000eu,0x6e6d000fu,0x6a690010u,0x75740011u,0x6a690012u,0x77760013u,0x66650014u,0x2f2e0015u,0x6a610016u,0x7574001fu,0x0u,0x706f002fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640034u,0x75740020u,0x73720021u,0x6a690022u,0x63620023u,0x76750024u,0x75740025u,0x66650026u,0x34300027u,0x100002bu,0x100002cu,0x100002du,0x100002eu,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c0030u,0x706f0031u,0x73720032u,0x1000033u,0x80000001u,0x100003fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640040u,0x80000006u,0x66650041u,0x79780042u,0x1000043u,0x8000000eu,0x65640045u,0x6a690046u,0x76750047u,0x74730048u,0x1000049u,0x8000000fu,0x6564004bu,0x3b3a004cu,0x3b3a004du,0x7574004eu,0x6a69004fu,0x6e6d0050u,0x66650051u,0x57000052u,0x80000010u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100a9u,0x737200aau,0x7a7900abu,0x6a6900acu,0x6f6e00adu,0x686700aeu,0x10000afu,0x80000011u,0x737200b1u,0x757400b2u,0x666500b3u,0x797800b4u,0x2f2e00b5u,0x736100b6u,0x757400c8u,0x0u,0x706f00d8u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f00ddu,0x0u,0x626100e5u,0x757400c9u,0x737200cau,0x6a6900cbu,0x636200ccu,0x767500cdu,0x757400ceu,0x666500cfu,0x343000d0u,0x10000d4u,0x10000d5u,0x10000d6u,0x10000d7u,0x8000000au,0x8000000bu,0x8000000cu,0x8000000du,0x6d6c00d9u,0x706f00dau,0x737200dbu,0x10000dcu,0x80000009u,0x747300deu,0x6a6900dfu,0x757400e0u,0x6a6900e1u,0x706f00e2u,0x6f6e00e3u,0x10000e4u,0x80000007u,0x656400e6u,0x6a6900e7u,0x767500e8u,0x747300e9u,0x10000eau,0x80000008u};
      uint32_t cur = 0x776e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_curve(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.radius
            ANARIDataType vertex_radius_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_radius_types);
            return;
         }
         case 9: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_color_types);
            return;
         }
         case 10: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 11: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 12: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 13: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 14: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_index_types);
            return;
         }
         case 15: { //radius
            ANARIDataType radius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, radius_types);
            return;
         }
         case 16: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, usd__time_types);
            return;
         }
         case 17: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "curve", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "curve";
   }
};
class geometry_cylinder : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610014u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610018u,0x0u,0x7372001cu,0x0u,0x62610062u,0x0u,0x0u,0x74730068u,0x666500ceu,0x71700015u,0x74730016u,0x1000017u,0x80000011u,0x6e6d0019u,0x6665001au,0x100001bu,0x80000000u,0x6a69001du,0x6e6d001eu,0x6a69001fu,0x75740020u,0x6a690021u,0x77760022u,0x66650023u,0x2f2e0024u,0x73610025u,0x75740037u,0x0u,0x706f0047u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f64004cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261005cu,0x75740038u,0x73720039u,0x6a69003au,0x6362003bu,0x7675003cu,0x7574003du,0x6665003eu,0x3430003fu,0x1000043u,0x1000044u,0x1000045u,0x1000046u,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c0048u,0x706f0049u,0x7372004au,0x100004bu,0x80000001u,0x1000057u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640058u,0x80000006u,0x66650059u,0x7978005au,0x100005bu,0x8000000eu,0x6564005du,0x6a69005eu,0x7675005fu,0x74730060u,0x1000061u,0x8000000fu,0x65640063u,0x6a690064u,0x76750065u,0x74730066u,0x1000067u,0x80000010u,0x65640069u,0x3b3a006au,0x3b3a006bu,0x7574006cu,0x6a69006du,0x6e6d006eu,0x6665006fu,0x57000070u,0x80000012u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100c7u,0x737200c8u,0x7a7900c9u,0x6a6900cau,0x6f6e00cbu,0x686700ccu,0x10000cdu,0x80000013u,0x737200cfu,0x757400d0u,0x666500d1u,0x797800d2u,0x2f2e00d3u,0x716100d4u,0x757400e4u,0x0u,0x706100f4u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0109u,0x757400e5u,0x737200e6u,0x6a6900e7u,0x636200e8u,0x767500e9u,0x757400eau,0x666500ebu,0x343000ecu,0x10000f0u,0x10000f1u,0x10000f2u,0x10000f3u,0x8000000au,0x8000000bu,0x8000000cu,0x8000000du,0x71700103u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c0105u,0x1000104u,0x80000008u,0x706f0106u,0x73720107u,0x1000108u,0x80000009u,0x7473010au,0x6a69010bu,0x7574010cu,0x6a69010du,0x706f010eu,0x6f6e010fu,0x1000110u,0x80000007u};
      uint32_t cur = 0x77630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_cylinder(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.cap
            ANARIDataType vertex_cap_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_cap_types);
            return;
         }
         case 9: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_color_types);
            return;
         }
         case 10: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 11: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 12: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 13: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 14: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_index_types);
            return;
         }
         case 15: { //primitive.radius
            ANARIDataType primitive_radius_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_radius_types);
            return;
         }
         case 16: { //radius
            ANARIDataType radius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, radius_types);
            return;
         }
         case 17: { //caps
            ANARIDataType caps_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, caps_types);
            return;
         }
         case 18: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, usd__time_types);
            return;
         }
         case 19: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "cylinder", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "cylinder";
   }
};
class geometry_quad : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610009u,0x0u,0x7372000du,0x0u,0x0u,0x0u,0x0u,0x74730044u,0x666500aau,0x6e6d000au,0x6665000bu,0x100000cu,0x80000000u,0x6a69000eu,0x6e6d000fu,0x6a690010u,0x75740011u,0x6a690012u,0x77760013u,0x66650014u,0x2f2e0015u,0x6a610016u,0x7574001fu,0x0u,0x706f002fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640034u,0x75740020u,0x73720021u,0x6a690022u,0x63620023u,0x76750024u,0x75740025u,0x66650026u,0x34300027u,0x100002bu,0x100002cu,0x100002du,0x100002eu,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c0030u,0x706f0031u,0x73720032u,0x1000033u,0x80000001u,0x100003fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640040u,0x80000006u,0x66650041u,0x79780042u,0x1000043u,0x8000000eu,0x65640045u,0x3b3a0046u,0x3b3a0047u,0x75740048u,0x6a690049u,0x6e6d004au,0x6665004bu,0x5700004cu,0x8000000fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100a3u,0x737200a4u,0x7a7900a5u,0x6a6900a6u,0x6f6e00a7u,0x686700a8u,0x10000a9u,0x80000010u,0x737200abu,0x757400acu,0x666500adu,0x797800aeu,0x2f2e00afu,0x716100b0u,0x757400c0u,0x0u,0x706f00d0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f00d5u,0x0u,0x706f00dbu,0x757400c1u,0x737200c2u,0x6a6900c3u,0x636200c4u,0x767500c5u,0x757400c6u,0x666500c7u,0x343000c8u,0x10000ccu,0x10000cdu,0x10000ceu,0x10000cfu,0x8000000au,0x8000000bu,0x8000000cu,0x8000000du,0x6d6c00d1u,0x706f00d2u,0x737200d3u,0x10000d4u,0x80000009u,0x737200d6u,0x6e6d00d7u,0x626100d8u,0x6d6c00d9u,0x10000dau,0x80000008u,0x747300dcu,0x6a6900ddu,0x757400deu,0x6a6900dfu,0x706f00e0u,0x6f6e00e1u,0x10000e2u,0x80000007u};
      uint32_t cur = 0x776e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_quad(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.normal
            ANARIDataType vertex_normal_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_normal_types);
            return;
         }
         case 9: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_color_types);
            return;
         }
         case 10: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 11: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 12: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 13: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 14: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_index_types);
            return;
         }
         case 15: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, usd__time_types);
            return;
         }
         case 16: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "quad", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "quad";
   }
};
class geometry_sphere : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610009u,0x0u,0x7372000du,0x0u,0x62610044u,0x0u,0x0u,0x7473004au,0x666500b0u,0x6e6d000au,0x6665000bu,0x100000cu,0x80000000u,0x6a69000eu,0x6e6d000fu,0x6a690010u,0x75740011u,0x6a690012u,0x77760013u,0x66650014u,0x2f2e0015u,0x6a610016u,0x7574001fu,0x0u,0x706f002fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640034u,0x75740020u,0x73720021u,0x6a690022u,0x63620023u,0x76750024u,0x75740025u,0x66650026u,0x34300027u,0x100002bu,0x100002cu,0x100002du,0x100002eu,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c0030u,0x706f0031u,0x73720032u,0x1000033u,0x80000001u,0x100003fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640040u,0x80000006u,0x66650041u,0x79780042u,0x1000043u,0x8000000eu,0x65640045u,0x6a690046u,0x76750047u,0x74730048u,0x1000049u,0x8000000fu,0x6564004bu,0x3b3a004cu,0x3b3a004du,0x7574004eu,0x6a69004fu,0x6e6d0050u,0x66650051u,0x57000052u,0x80000010u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100a9u,0x737200aau,0x7a7900abu,0x6a6900acu,0x6f6e00adu,0x686700aeu,0x10000afu,0x80000011u,0x737200b1u,0x757400b2u,0x666500b3u,0x797800b4u,0x2f2e00b5u,0x736100b6u,0x757400c8u,0x0u,0x706f00d8u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f00ddu,0x0u,0x626100e5u,0x757400c9u,0x737200cau,0x6a6900cbu,0x636200ccu,0x767500cdu,0x757400ceu,0x666500cfu,0x343000d0u,0x10000d4u,0x10000d5u,0x10000d6u,0x10000d7u,0x8000000au,0x8000000bu,0x8000000cu,0x8000000du,0x6d6c00d9u,0x706f00dau,0x737200dbu,0x10000dcu,0x80000009u,0x747300deu,0x6a6900dfu,0x757400e0u,0x6a6900e1u,0x706f00e2u,0x6f6e00e3u,0x10000e4u,0x80000007u,0x656400e6u,0x6a6900e7u,0x767500e8u,0x747300e9u,0x10000eau,0x80000008u};
      uint32_t cur = 0x776e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_sphere(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.radius
            ANARIDataType vertex_radius_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_radius_types);
            return;
         }
         case 9: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_color_types);
            return;
         }
         case 10: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 11: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 12: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 13: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 14: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_index_types);
            return;
         }
         case 15: { //radius
            ANARIDataType radius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, radius_types);
            return;
         }
         case 16: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, usd__time_types);
            return;
         }
         case 17: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "sphere", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "sphere";
   }
};
class geometry_triangle : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610009u,0x0u,0x7372000du,0x0u,0x0u,0x0u,0x0u,0x74730044u,0x666500aau,0x6e6d000au,0x6665000bu,0x100000cu,0x80000000u,0x6a69000eu,0x6e6d000fu,0x6a690010u,0x75740011u,0x6a690012u,0x77760013u,0x66650014u,0x2f2e0015u,0x6a610016u,0x7574001fu,0x0u,0x706f002fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640034u,0x75740020u,0x73720021u,0x6a690022u,0x63620023u,0x76750024u,0x75740025u,0x66650026u,0x34300027u,0x100002bu,0x100002cu,0x100002du,0x100002eu,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c0030u,0x706f0031u,0x73720032u,0x1000033u,0x80000001u,0x100003fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640040u,0x80000006u,0x66650041u,0x79780042u,0x1000043u,0x8000000eu,0x65640045u,0x3b3a0046u,0x3b3a0047u,0x75740048u,0x6a690049u,0x6e6d004au,0x6665004bu,0x5700004cu,0x8000000fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100a3u,0x737200a4u,0x7a7900a5u,0x6a6900a6u,0x6f6e00a7u,0x686700a8u,0x10000a9u,0x80000010u,0x737200abu,0x757400acu,0x666500adu,0x797800aeu,0x2f2e00afu,0x716100b0u,0x757400c0u,0x0u,0x706f00d0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f00d5u,0x0u,0x706f00dbu,0x757400c1u,0x737200c2u,0x6a6900c3u,0x636200c4u,0x767500c5u,0x757400c6u,0x666500c7u,0x343000c8u,0x10000ccu,0x10000cdu,0x10000ceu,0x10000cfu,0x8000000au,0x8000000bu,0x8000000cu,0x8000000du,0x6d6c00d1u,0x706f00d2u,0x737200d3u,0x10000d4u,0x80000009u,0x737200d6u,0x6e6d00d7u,0x626100d8u,0x6d6c00d9u,0x10000dau,0x80000008u,0x747300dcu,0x6a6900ddu,0x757400deu,0x6a6900dfu,0x706f00e0u,0x6f6e00e1u,0x10000e2u,0x80000007u};
      uint32_t cur = 0x776e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_triangle(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.normal
            ANARIDataType vertex_normal_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_normal_types);
            return;
         }
         case 9: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_color_types);
            return;
         }
         case 10: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 11: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 12: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 13: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 14: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_index_types);
            return;
         }
         case 15: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, usd__time_types);
            return;
         }
         case 16: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "triangle", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "triangle";
   }
};
class material_matte : public DebugObject<ANARI_MATERIAL> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x706f0013u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610018u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7473001cu,0x6d6c0014u,0x706f0015u,0x73720016u,0x1000017u,0x80000001u,0x6e6d0019u,0x6665001au,0x100001bu,0x80000000u,0x6564001du,0x3b3a001eu,0x3b3a001fu,0x75740020u,0x6a690021u,0x6e6d0022u,0x66650023u,0x57000024u,0x80000002u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261007bu,0x7372007cu,0x7a79007du,0x6a69007eu,0x6f6e007fu,0x68670080u,0x1000081u,0x80000003u};
      uint32_t cur = 0x76630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   material_matte(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "matte", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3,ANARI_SAMPLER,ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "matte", paramname, paramtype, color_types);
            return;
         }
         case 2: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "matte", paramname, paramtype, usd__time_types);
            return;
         }
         case 3: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "matte", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_MATERIAL, "matte", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "matte";
   }
};
class material_transparentMatte : public DebugObject<ANARI_MATERIAL> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x706f0013u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610018u,0x7170001cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x74730023u,0x6d6c0014u,0x706f0015u,0x73720016u,0x1000017u,0x80000001u,0x6e6d0019u,0x6665001au,0x100001bu,0x80000000u,0x6261001du,0x6463001eu,0x6a69001fu,0x75740020u,0x7a790021u,0x1000022u,0x80000002u,0x65640024u,0x3b3a0025u,0x3b3a0026u,0x75740027u,0x6a690028u,0x6e6d0029u,0x6665002au,0x5700002bu,0x80000003u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610082u,0x73720083u,0x7a790084u,0x6a690085u,0x6f6e0086u,0x68670087u,0x1000088u,0x80000004u};
      uint32_t cur = 0x76630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   material_transparentMatte(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3,ANARI_SAMPLER,ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, color_types);
            return;
         }
         case 2: { //opacity
            ANARIDataType opacity_types[] = {ANARI_FLOAT32,ANARI_SAMPLER,ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, opacity_types);
            return;
         }
         case 3: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, usd__time_types);
            return;
         }
         case 4: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_MATERIAL, "transparentMatte", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "transparentMatte";
   }
};
class sampler_image1D : public DebugObject<ANARI_SAMPLER> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6a690012u,0x0u,0x0u,0x6f6d0018u,0x0u,0x0u,0x0u,0x0u,0x62610044u,0x76750048u,0x0u,0x0u,0x0u,0x0u,0x0u,0x74730054u,0x0u,0x737200bau,0x6d6c0013u,0x75740014u,0x66650015u,0x73720016u,0x1000017u,0x80000003u,0x6261001au,0x5541001eu,0x6867001bu,0x6665001cu,0x100001du,0x80000001u,0x75740032u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372003bu,0x75740033u,0x73720034u,0x6a690035u,0x63620036u,0x76750037u,0x75740038u,0x66650039u,0x100003au,0x80000002u,0x6261003cu,0x6f6e003du,0x7473003eu,0x6766003fu,0x706f0040u,0x73720041u,0x6e6d0042u,0x1000043u,0x80000005u,0x6e6d0045u,0x66650046u,0x1000047u,0x80000000u,0x75740049u,0x5554004au,0x7372004bu,0x6261004cu,0x6f6e004du,0x7473004eu,0x6766004fu,0x706f0050u,0x73720051u,0x6e6d0052u,0x1000053u,0x80000006u,0x65640055u,0x3b3a0056u,0x3b3a0057u,0x75740058u,0x6a690059u,0x6e6d005au,0x6665005bu,0x5700005cu,0x80000007u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100b3u,0x737200b4u,0x7a7900b5u,0x6a6900b6u,0x6f6e00b7u,0x686700b8u,0x10000b9u,0x80000008u,0x626100bbu,0x717000bcu,0x4e4d00bdu,0x706f00beu,0x656400bfu,0x666500c0u,0x323100c1u,0x10000c2u,0x80000004u};
      uint32_t cur = 0x78660000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   sampler_image1D(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, name_types);
            return;
         }
         case 1: { //image
            ANARIDataType image_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, image_types);
            return;
         }
         case 2: { //inAttribute
            ANARIDataType inAttribute_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, inAttribute_types);
            return;
         }
         case 3: { //filter
            ANARIDataType filter_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, filter_types);
            return;
         }
         case 4: { //wrapMode1
            ANARIDataType wrapMode1_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, wrapMode1_types);
            return;
         }
         case 5: { //inTransform
            ANARIDataType inTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, inTransform_types);
            return;
         }
         case 6: { //outTransform
            ANARIDataType outTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, outTransform_types);
            return;
         }
         case 7: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, usd__time_types);
            return;
         }
         case 8: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SAMPLER, "image1D", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "image1D";
   }
};
class sampler_image2D : public DebugObject<ANARI_SAMPLER> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6a690012u,0x0u,0x0u,0x6f6d0018u,0x0u,0x0u,0x0u,0x0u,0x62610044u,0x76750048u,0x0u,0x0u,0x0u,0x0u,0x0u,0x74730054u,0x0u,0x737200bau,0x6d6c0013u,0x75740014u,0x66650015u,0x73720016u,0x1000017u,0x80000003u,0x6261001au,0x5541001eu,0x6867001bu,0x6665001cu,0x100001du,0x80000001u,0x75740032u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372003bu,0x75740033u,0x73720034u,0x6a690035u,0x63620036u,0x76750037u,0x75740038u,0x66650039u,0x100003au,0x80000002u,0x6261003cu,0x6f6e003du,0x7473003eu,0x6766003fu,0x706f0040u,0x73720041u,0x6e6d0042u,0x1000043u,0x80000006u,0x6e6d0045u,0x66650046u,0x1000047u,0x80000000u,0x75740049u,0x5554004au,0x7372004bu,0x6261004cu,0x6f6e004du,0x7473004eu,0x6766004fu,0x706f0050u,0x73720051u,0x6e6d0052u,0x1000053u,0x80000007u,0x65640055u,0x3b3a0056u,0x3b3a0057u,0x75740058u,0x6a690059u,0x6e6d005au,0x6665005bu,0x5700005cu,0x80000008u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100b3u,0x737200b4u,0x7a7900b5u,0x6a6900b6u,0x6f6e00b7u,0x686700b8u,0x10000b9u,0x80000009u,0x626100bbu,0x717000bcu,0x4e4d00bdu,0x706f00beu,0x656400bfu,0x666500c0u,0x333100c1u,0x10000c3u,0x10000c4u,0x80000004u,0x80000005u};
      uint32_t cur = 0x78660000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   sampler_image2D(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, name_types);
            return;
         }
         case 1: { //image
            ANARIDataType image_types[] = {ANARI_ARRAY2D, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, image_types);
            return;
         }
         case 2: { //inAttribute
            ANARIDataType inAttribute_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, inAttribute_types);
            return;
         }
         case 3: { //filter
            ANARIDataType filter_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, filter_types);
            return;
         }
         case 4: { //wrapMode1
            ANARIDataType wrapMode1_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, wrapMode1_types);
            return;
         }
         case 5: { //wrapMode2
            ANARIDataType wrapMode2_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, wrapMode2_types);
            return;
         }
         case 6: { //inTransform
            ANARIDataType inTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, inTransform_types);
            return;
         }
         case 7: { //outTransform
            ANARIDataType outTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, outTransform_types);
            return;
         }
         case 8: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, usd__time_types);
            return;
         }
         case 9: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SAMPLER, "image2D", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "image2D";
   }
};
class sampler_image3D : public DebugObject<ANARI_SAMPLER> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6a690012u,0x0u,0x0u,0x6f6d0018u,0x0u,0x0u,0x0u,0x0u,0x62610044u,0x76750048u,0x0u,0x0u,0x0u,0x0u,0x0u,0x74730054u,0x0u,0x737200bau,0x6d6c0013u,0x75740014u,0x66650015u,0x73720016u,0x1000017u,0x80000003u,0x6261001au,0x5541001eu,0x6867001bu,0x6665001cu,0x100001du,0x80000001u,0x75740032u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372003bu,0x75740033u,0x73720034u,0x6a690035u,0x63620036u,0x76750037u,0x75740038u,0x66650039u,0x100003au,0x80000002u,0x6261003cu,0x6f6e003du,0x7473003eu,0x6766003fu,0x706f0040u,0x73720041u,0x6e6d0042u,0x1000043u,0x80000007u,0x6e6d0045u,0x66650046u,0x1000047u,0x80000000u,0x75740049u,0x5554004au,0x7372004bu,0x6261004cu,0x6f6e004du,0x7473004eu,0x6766004fu,0x706f0050u,0x73720051u,0x6e6d0052u,0x1000053u,0x80000008u,0x65640055u,0x3b3a0056u,0x3b3a0057u,0x75740058u,0x6a690059u,0x6e6d005au,0x6665005bu,0x5700005cu,0x80000009u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100b3u,0x737200b4u,0x7a7900b5u,0x6a6900b6u,0x6f6e00b7u,0x686700b8u,0x10000b9u,0x8000000au,0x626100bbu,0x717000bcu,0x4e4d00bdu,0x706f00beu,0x656400bfu,0x666500c0u,0x343100c1u,0x10000c4u,0x10000c5u,0x10000c6u,0x80000004u,0x80000005u,0x80000006u};
      uint32_t cur = 0x78660000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   sampler_image3D(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, name_types);
            return;
         }
         case 1: { //image
            ANARIDataType image_types[] = {ANARI_ARRAY3D, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, image_types);
            return;
         }
         case 2: { //inAttribute
            ANARIDataType inAttribute_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, inAttribute_types);
            return;
         }
         case 3: { //filter
            ANARIDataType filter_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, filter_types);
            return;
         }
         case 4: { //wrapMode1
            ANARIDataType wrapMode1_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, wrapMode1_types);
            return;
         }
         case 5: { //wrapMode2
            ANARIDataType wrapMode2_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, wrapMode2_types);
            return;
         }
         case 6: { //wrapMode3
            ANARIDataType wrapMode3_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, wrapMode3_types);
            return;
         }
         case 7: { //inTransform
            ANARIDataType inTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, inTransform_types);
            return;
         }
         case 8: { //outTransform
            ANARIDataType outTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, outTransform_types);
            return;
         }
         case 9: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, usd__time_types);
            return;
         }
         case 10: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SAMPLER, "image3D", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "image3D";
   }
};
class spatial_field_structuredRegular : public DebugObject<ANARI_SPATIAL_FIELD> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610012u,0x0u,0x6a690016u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261001cu,0x73720020u,0x0u,0x0u,0x0u,0x71700026u,0x0u,0x7473002du,0x75740013u,0x62610014u,0x1000015u,0x80000001u,0x6d6c0017u,0x75740018u,0x66650019u,0x7372001au,0x100001bu,0x80000004u,0x6e6d001du,0x6665001eu,0x100001fu,0x80000000u,0x6a690021u,0x68670022u,0x6a690023u,0x6f6e0024u,0x1000025u,0x80000002u,0x62610027u,0x64630028u,0x6a690029u,0x6f6e002au,0x6867002bu,0x100002cu,0x80000003u,0x6564002eu,0x3b3a002fu,0x3b3a0030u,0x75740031u,0x6a690032u,0x6e6d0033u,0x66650034u,0x57000035u,0x80000005u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261008cu,0x7372008du,0x7a79008eu,0x6a69008fu,0x6f6e0090u,0x68670091u,0x1000092u,0x80000006u};
      uint32_t cur = 0x76640000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   spatial_field_structuredRegular(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, name_types);
            return;
         }
         case 1: { //data
            ANARIDataType data_types[] = {ANARI_ARRAY3D, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, data_types);
            return;
         }
         case 2: { //origin
            ANARIDataType origin_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, origin_types);
            return;
         }
         case 3: { //spacing
            ANARIDataType spacing_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, spacing_types);
            return;
         }
         case 4: { //filter
            ANARIDataType filter_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, filter_types);
            return;
         }
         case 5: { //usd::time
            ANARIDataType usd__time_types[] = {ANARI_FLOAT64, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, usd__time_types);
            return;
         }
         case 6: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "structuredRegular";
   }
};
class volume_scivis : public DebugObject<ANARI_VOLUME> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x706f0014u,0x66650050u,0x0u,0x6a69005cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610061u,0x71700065u,0x0u,0x0u,0x0u,0x0u,0x0u,0x747300a3u,0x626100b3u,0x6d6c0015u,0x706f0016u,0x73720017u,0x2f000018u,0x80000003u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x71700047u,0x706f0048u,0x74730049u,0x6a69004au,0x7574004bu,0x6a69004cu,0x706f004du,0x6f6e004eu,0x100004fu,0x80000004u,0x6f6e0051u,0x74730052u,0x6a690053u,0x75740054u,0x7a790055u,0x54530056u,0x64630057u,0x62610058u,0x6d6c0059u,0x6665005au,0x100005bu,0x80000007u,0x6665005du,0x6d6c005eu,0x6564005fu,0x1000060u,0x80000001u,0x6e6d0062u,0x66650063u,0x1000064u,0x80000000u,0x62610066u,0x64630067u,0x6a690068u,0x75740069u,0x7a79006au,0x2f00006bu,0x80000005u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7170009au,0x706f009bu,0x7473009cu,0x6a69009du,0x7574009eu,0x6a69009fu,0x706f00a0u,0x6f6e00a1u,0x10000a2u,0x80000006u,0x656400a4u,0x3b3a00a5u,0x3b3a00a6u,0x757400a7u,0x6a6900a8u,0x6e6d00a9u,0x666500aau,0x575600abu,0x626100acu,0x737200adu,0x7a7900aeu,0x6a6900afu,0x6f6e00b0u,0x686700b1u,0x10000b2u,0x80000008u,0x6d6c00b4u,0x767500b5u,0x666500b6u,0x535200b7u,0x626100b8u,0x6f6e00b9u,0x686700bau,0x666500bbu,0x10000bcu,0x80000002u};
      uint32_t cur = 0x77630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   volume_scivis(DebugDevice *td, UsdDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, name_types);
            return;
         }
         case 1: { //field
            ANARIDataType field_types[] = {ANARI_SPATIAL_FIELD, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, field_types);
            return;
         }
         case 2: { //valueRange
            ANARIDataType valueRange_types[] = {ANARI_FLOAT32_BOX1, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, valueRange_types);
            return;
         }
         case 3: { //color
            ANARIDataType color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, color_types);
            return;
         }
         case 4: { //color.position
            ANARIDataType color_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, color_position_types);
            return;
         }
         case 5: { //opacity
            ANARIDataType opacity_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, opacity_types);
            return;
         }
         case 6: { //opacity.position
            ANARIDataType opacity_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, opacity_position_types);
            return;
         }
         case 7: { //densityScale
            ANARIDataType densityScale_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, densityScale_types);
            return;
         }
         case 8: { //usd::timeVarying
            ANARIDataType usd__timeVarying_types[] = {ANARI_INT32, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, usd__timeVarying_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_VOLUME, "scivis", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "scivis";
   }
};
}
static int geometry_object_hash(const char *str) {
   static const uint32_t table[] = {0x7a6f0012u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7675002bu,0x0u,0x7170002fu,0x73720035u,0x6f6e001du,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720020u,0x0u,0x0u,0x0u,0x6d6c0024u,0x6665001eu,0x100001fu,0x80000000u,0x77760021u,0x66650022u,0x1000023u,0x80000001u,0x6a690025u,0x6f6e0026u,0x65640027u,0x66650028u,0x73720029u,0x100002au,0x80000002u,0x6261002cu,0x6564002du,0x100002eu,0x80000003u,0x69680030u,0x66650031u,0x73720032u,0x66650033u,0x1000034u,0x80000004u,0x6a690036u,0x62610037u,0x6f6e0038u,0x68670039u,0x6d6c003au,0x6665003bu,0x100003cu,0x80000005u};
   uint32_t cur = 0x75630000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* UsdDeviceDebugFactory::new_geometry(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = geometry_object_hash(name);
   switch(idx) {
      case 0:
         return new geometry_cone(td, this, wh, h);
      case 1:
         return new geometry_curve(td, this, wh, h);
      case 2:
         return new geometry_cylinder(td, this, wh, h);
      case 3:
         return new geometry_quad(td, this, wh, h);
      case 4:
         return new geometry_sphere(td, this, wh, h);
      case 5:
         return new geometry_triangle(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_GEOMETRY, name);
         return new SubtypedDebugObject<ANARI_GEOMETRY>(td, wh, h, name);
   }
}
static int material_object_hash(const char *str) {
   static const uint32_t table[] = {0x62610008u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372000du,0x75740009u,0x7574000au,0x6665000bu,0x100000cu,0x80000000u,0x6261000eu,0x6f6e000fu,0x74730010u,0x71700011u,0x62610012u,0x73720013u,0x66650014u,0x6f6e0015u,0x75740016u,0x4e4d0017u,0x62610018u,0x75740019u,0x7574001au,0x6665001bu,0x100001cu,0x80000001u};
   uint32_t cur = 0x756d0000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* UsdDeviceDebugFactory::new_material(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = material_object_hash(name);
   switch(idx) {
      case 0:
         return new material_matte(td, this, wh, h);
      case 1:
         return new material_transparentMatte(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_MATERIAL, name);
         return new SubtypedDebugObject<ANARI_MATERIAL>(td, wh, h, name);
   }
}
static int renderer_object_hash(const char *str) {
   static const uint32_t table[] = {0x66650001u,0x67660002u,0x62610003u,0x76750004u,0x6d6c0005u,0x75740006u,0x1000007u,0x80000000u};
   uint32_t cur = 0x65640000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* UsdDeviceDebugFactory::new_renderer(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = renderer_object_hash(name);
   switch(idx) {
      case 0:
         return new renderer_default(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_RENDERER, name);
         return new SubtypedDebugObject<ANARI_RENDERER>(td, wh, h, name);
   }
}
static int sampler_object_hash(const char *str) {
   static const uint32_t table[] = {0x6e6d0001u,0x62610002u,0x68670003u,0x66650004u,0x34310005u,0x45440008u,0x4544000au,0x4544000cu,0x1000009u,0x80000000u,0x100000bu,0x80000001u,0x100000du,0x80000002u};
   uint32_t cur = 0x6a690000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* UsdDeviceDebugFactory::new_sampler(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = sampler_object_hash(name);
   switch(idx) {
      case 0:
         return new sampler_image1D(td, this, wh, h);
      case 1:
         return new sampler_image2D(td, this, wh, h);
      case 2:
         return new sampler_image3D(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_SAMPLER, name);
         return new SubtypedDebugObject<ANARI_SAMPLER>(td, wh, h, name);
   }
}
static int spatial_field_object_hash(const char *str) {
   static const uint32_t table[] = {0x75740001u,0x73720002u,0x76750003u,0x64630004u,0x75740005u,0x76750006u,0x73720007u,0x66650008u,0x65640009u,0x5352000au,0x6665000bu,0x6867000cu,0x7675000du,0x6d6c000eu,0x6261000fu,0x73720010u,0x1000011u,0x80000000u};
   uint32_t cur = 0x74730000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* UsdDeviceDebugFactory::new_spatial_field(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = spatial_field_object_hash(name);
   switch(idx) {
      case 0:
         return new spatial_field_structuredRegular(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_SPATIAL_FIELD, name);
         return new SubtypedDebugObject<ANARI_SPATIAL_FIELD>(td, wh, h, name);
   }
}
static int volume_object_hash(const char *str) {
   static const uint32_t table[] = {0x64630001u,0x6a690002u,0x77760003u,0x6a690004u,0x74730005u,0x1000006u,0x80000000u};
   uint32_t cur = 0x74730000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* UsdDeviceDebugFactory::new_volume(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = volume_object_hash(name);
   switch(idx) {
      case 0:
         return new volume_scivis(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_VOLUME, name);
         return new SubtypedDebugObject<ANARI_VOLUME>(td, wh, h, name);
   }
}
DebugObjectBase* UsdDeviceDebugFactory::new_array1d(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new array1d(td, this, wh, h);
}
DebugObjectBase* UsdDeviceDebugFactory::new_array2d(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new array2d(td, this, wh, h);
}
DebugObjectBase* UsdDeviceDebugFactory::new_array3d(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new array3d(td, this, wh, h);
}
DebugObjectBase* UsdDeviceDebugFactory::new_device(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new device(td, this, wh, h);
}
DebugObjectBase* UsdDeviceDebugFactory::new_frame(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new frame(td, this, wh, h);
}
DebugObjectBase* UsdDeviceDebugFactory::new_group(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new group(td, this, wh, h);
}
DebugObjectBase* UsdDeviceDebugFactory::new_instance(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new instance(td, this, wh, h);
}
DebugObjectBase* UsdDeviceDebugFactory::new_surface(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new surface(td, this, wh, h);
}
DebugObjectBase* UsdDeviceDebugFactory::new_world(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new world(td, this, wh, h);
}
void UsdDeviceDebugFactory::print_summary(DebugDevice *td) {
   (void)td;
}
anari::debug_device::ObjectFactory* getDebugFactory() {
   static UsdDeviceDebugFactory f;
   return &f;
}
}
}
